<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Phoenix-Logo-16B.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Phoenix-Logo-16B.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"phoenixdai.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":"mac","style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Paper Name  Web: http:&#x2F;&#x2F;phoenixdai.cn Citing info.  Solve probs, Merits Main work Conclusion">
<meta property="og:type" content="article">
<meta property="og:title" content="BGFL-Improve-GraphDiv">
<meta property="og:url" content="http://phoenixdai.cn/2022/10/26/BGFL-Improve-GraphDiv/index.html">
<meta property="og:site_name" content="Sycamore">
<meta property="og:description" content="Paper Name  Web: http:&#x2F;&#x2F;phoenixdai.cn Citing info.  Solve probs, Merits Main work Conclusion">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211061809284.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211062034003.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211062036637.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211062044237.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211062048700.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211071033532.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211071038811.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211071102464.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211071106259.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211071108206.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211081537063.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211071229778.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211081649225.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211081543191.png">
<meta property="article:published_time" content="2022-10-26T08:56:15.000Z">
<meta property="article:modified_time" content="2023-09-04T08:26:19.140Z">
<meta property="article:author" content="PhoenixDai">
<meta property="article:tag" content="My-Papers">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211061809284.png">

<link rel="canonical" href="http://phoenixdai.cn/2022/10/26/BGFL-Improve-GraphDiv/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>BGFL-Improve-GraphDiv | Sycamore</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sycamore</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Phoenix reborns from the ashe</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://phoenixdai.cn/2022/10/26/BGFL-Improve-GraphDiv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Phoenix-Logo-White.png">
      <meta itemprop="name" content="PhoenixDai">
      <meta itemprop="description" content="Anything that doesn't kill me makes me stronger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sycamore">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          BGFL-Improve-GraphDiv
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-26 16:56:15" itemprop="dateCreated datePublished" datetime="2022-10-26T16:56:15+08:00">2022-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-04 16:26:19" itemprop="dateModified" datetime="2023-09-04T16:26:19+08:00">2023-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/XF-TANK/" itemprop="url" rel="index"><span itemprop="name">XF-TANK</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>Paper Name</strong></p>
<blockquote>
<p>Web: <a href="http://phoenixdai.cn">http://phoenixdai.cn</a></p>
<p>Citing info.</p>
</blockquote>
<p><strong>Solve probs, Merits</strong></p>
<p><strong>Main work</strong></p>
<p><strong>Conclusion</strong></p>
<hr />
<p><span id="more"></span></p>
<h2 id="preliminaries">Preliminaries</h2>
<h3 id="super-graph">Super Graph</h3>
<p><strong>超图是什么？</strong></p>
<p>简单的来说，对于我们熟悉的图而言，它的一个边（edge）只能和<strong>两个</strong>点连接；而对于超图来讲，人们定义它的边（这里叫超边，hyperedge, nets）可以和<strong>任意个数</strong>的顶点连接。</p>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211061809284.png" /></p>
<p>上图看的很清楚，所谓的超图就是每个边连接的顶点数不再是两个，而是任意一个。而<strong>均匀超图</strong>的概念就是每一个边所连接的点的个数是相同的，即：</p>
<ul>
<li>2-均匀超图 = 图</li>
</ul>
<p>在数学层面上，超图的定义为<span class="math inline">\(H = (X, E)\)</span>，其中<span class="math inline">\(X\)</span>是点（vertices）的集合，<span class="math inline">\(E\)</span>是边的集合，这里的<span class="math inline">\(E\)</span>就变成了顶点集合<span class="math inline">\(X\)</span>的子集，因为每一个边都由<strong>若干个点的集合</strong>来表示。每一条超边中的点我们称之为针（pin）</p>
<p>加权无向超图：<span class="math inline">\(H=(V,E,c,\omega)\)</span>，其中<span class="math inline">\(c\)</span>是顶点权重，<span class="math inline">\(\omega\)</span>是超边的权重</p>
<h3 id="标签传播算法">标签传播算法</h3>
<p>标签传播算法简称<strong>LPA</strong>，是一种常用的半监督学习算法，用于向未标记（unlabel）的样本分配标签。LPA的核心思想非常简单：<strong>相似的数据应该拥有同样的标签。</strong>标签传播算法通过将所有样本依据相似性构建一个有权重的图，然后各个样本在其相邻的样本之间进行标签传播。</p>
<p>算法图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211062034003.png" /></p>
<ul>
<li>红色的数字代表对应节点的权重</li>
<li>黑色的数字代表边上的权重。</li>
</ul>
<p>最终的输出图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211062036637.png" /></p>
<p><strong>LPA原理：</strong></p>
<p>对于网络中的每一个节点，在初始阶段，LPA对每个节点初始化一个唯一的标签，在每次的迭代过程中，每个节点<strong>根据与其相连的节点所属的标签改变自己的标签</strong>，更改的原则是选择与其相连的节点中所属<strong>标签最多的社区标签</strong>为自己的社区标签，这便是标签传播的含义。</p>
<p>LPA包括两大步骤：1. 构造相似矩阵；2. 标签传播</p>
<p>构造相似矩阵：</p>
<p>因为LPA依赖图，所以我们第一步要构建一个Graph，图的节点就是我们的数据点，包含了Label和Unlabel的数据；边代表两个节点之间的相似度，相似度的计算公式如下所示，<span class="math inline">\(\alpha\)</span>是超参： <span class="math display">\[
w_{ij}=exp(-\frac{||x_i-x_j||^2}{\alpha^2})
\]</span> 标签传播：</p>
<p>在一开始，每一个节点都有自己的标签，即每一个节点都属于不同的社区，当社区的标签在节点间传播的时候，紧密相连的节点迅速取得一致的标签</p>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211062044237.png" /></p>
<ol type="1">
<li>对于c节点，由于周围节点都属于不同的社区，所以随机选择a社区</li>
<li>对于d节点，相邻属于a社区的最多，所以将标签改成a</li>
<li>同理对于b节点，相邻的节点中都是属于a社区的，所以标签改变成a</li>
</ol>
<p>在标签的更新中分为：同步更新；异步更新</p>
<p>同步更新是指对于一个节点<span class="math inline">\(x\)</span>，在<span class="math inline">\(t\)</span>时刻的更新，根据的是邻居节点在<span class="math inline">\(t-1\)</span>时刻的标签。 <span class="math display">\[
C_x(t)=f(C_{x_1}(t-1),...,C_{x_k}(t-1))
\]</span> 但是这种问题可能会导致标签震荡如下图：</p>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211062048700.png" /></p>
<p>在第一步的更新中，若左侧节点的标签更改为 a，右侧节点的标签更改为 b，在第二步中，左侧的节点又会更改为 b，右侧的节点又会更改为 a，如此往复，两边的标签会在社区标签 a 和 b 间不停地震荡。</p>
<p>对于异步更新方式： <span class="math display">\[
C_x(t)=f(C_{x_{i1}}(t),...,C_{x_{im}}(t),C_{x_{i(m+1)}}(t-1),...,C_{x_{ik}}(t-1))
\]</span> 其中，邻居节点<span class="math inline">\(x_{i1},...,x_{im}\)</span>的社区标签在第t代已经更新过，则使用其最新的社区标签。而邻居节点<span class="math inline">\(x_{i(m+1),...,x_{ik}}\)</span>在第<span class="math inline">\(t\)</span>代时还没有更新，则对于这些邻居节点还是用其在第<span class="math inline">\(t-1\)</span>代时的社区标签。</p>
<h3 id="fm-algorithm">FM Algorithm</h3>
<p>FM算法是一种改进网络分区的线性时间启发式算法，旨在减少不同分区之间的连接数。</p>
<p>FM主要用在超图的<em>双分区问题</em>。</p>
<p><strong>For Example</strong></p>
<p>我们对下面的电路图进行超图建模：</p>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211071033532.png" /></p>
<ul>
<li>(a)图中的每一个导线都连接多个门电路，这就是超图的超边</li>
<li>例如a,e,c由一根导线连接</li>
<li>(b)图即超图的直观表现</li>
</ul>
<p><strong>步骤如下：</strong></p>
<ol type="1">
<li><p>初始化分区</p>
<p>左图为超图，不同的线代表不同的超边，右图是超边集合</p>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211071038811.png" /></p>
<p>现随机将超图进行双分区，节点：a, c, d, g 在左边；节点：d, e, f, h在右边</p></li>
<li><p>计算gain值和初始化</p>
<ul>
<li><span class="math inline">\(FS(i)\)</span>：每当有超边包含节点<span class="math inline">\(i\)</span>，并且有且仅有<span class="math inline">\(i\)</span>在<span class="math inline">\(i\)</span>所属的分区：<span class="math inline">\(FS(i)=FS(i)+1\)</span>，初始值为0</li>
<li><span class="math inline">\(TE(i)\)</span>：每当有超边包含节点<span class="math inline">\(i\)</span>，且超边中所有的节点都在<span class="math inline">\(i\)</span>所属分区：<span class="math inline">\(TE(i)=TE(i)+1\)</span>，初始值为0</li>
<li><span class="math inline">\(gain(i)\)</span>：<span class="math inline">\(FS(i)+TE(i)\)</span></li>
</ul>
<p>对于元件c，c包含在超边<span class="math inline">\(n1=\{a,c,e\}，n3=\{c,f,e\}，n2=\{b,c,d\}\)</span>中，其中在超边n3中，只有元件c在左边的集合中，其他的元件都在右边的集合中，因此<span class="math inline">\(FS(c)+1\)</span>。</p>
<p>并没有超边中所有的元组都在左边，因此<span class="math inline">\(TE(c)=0\)</span>。</p>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211071102464.png" /></p></li>
<li><p>第一次移动</p>
<p>由上面第二步计算出所有元件的gain值，其中元件g和元件e的值都是2是最大的，而且对于g和e都是没有移动约束的。</p>
<p><strong>移动约束：尽量使得两边的元件数量维持一致，不能有太大的偏差，左边的数量和右边的数量要尽量维持相等</strong></p>
<p>根据字母顺序，将e从右边移动到左边，重新计算gain值。</p>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211071106259.png" /></p></li>
<li><p>第二次移动</p>
<p>虽然经过了第一次的移动<span class="math inline">\(gain(f)\)</span>的值是最大的，但是f有区域的移动约束（<strong>要是移动了f，便导致了左边的元件数量远远大于右边的元件数量，所以f不能移动</strong>），选择d元件进行移动</p>
<p><em>注意：已经移动过的节点不需要再重新计算gain，避免产生算法不收敛的情况。</em></p>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211071108206.png" /></p></li>
<li><p>一直移动到所有的点都不需要重新计算gain。</p>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211081537063.png" /></p></li>
</ol>
<h3 id="graph-coarsening">Graph Coarsening</h3>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=o0mhbHdfgTA">Graph Coarsening视频讲解</a></p>
<p>图的粗化（graph coarsening）是一种图压缩的算法。</p>
<p>计算出的聚类被压缩以获得一个更粗的图。 收缩聚类的工作方式如下：<strong>聚类的每个块收缩为单个节点。</strong></p>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211071229778.png" /></p>
<ul>
<li>节点的权重设置为原来块中所有节点权重的和</li>
<li>如果聚类中的两个对应块在G中相邻，则收缩图中的两个节点U和V之间存在边，即块U和块V至少有一条边相连，边的权重设为在聚类的块A和块B之间运行的边的权重之和</li>
</ul>
<hr />
<h2 id="复杂网络的平衡图分割">复杂网络的平衡图分割</h2>
<blockquote>
<p>网址：<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/7859409">https://ieeexplore.ieee.org/document/7859409</a></p>
<p>Meyerhenke, Henning, Peter Sanders, and Christian Schulz. "Parallel graph partitioning for complex networks." <em>IEEE Transactions on Parallel and Distributed Systems</em> 28.9 (2017): 2625-2638.</p>
</blockquote>
<h3 id="带有尺寸约束的标签传播算法">带有尺寸约束的标签传播算法</h3>
<blockquote>
<p>网址：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1402.3281">https://arxiv.org/abs/1402.3281</a></p>
<p>Meyerhenke, Henning, Peter Sanders, and Christian Schulz. "Partitioning complex networks via size-constrained clustering." <em>International Symposium on Experimental Algorithms</em>. Springer, Cham, 2014.</p>
</blockquote>
<p>算法大体流程：先利用标签传播算法进行聚类(有修改)，然后利用图的粗化将图压缩。</p>
<p>本论文意图将图分割成大小相近的多个块，所以定义了一个约束条件，即每一个块不能超过的权重大小<span class="math inline">\(L_{max}\)</span>。 <span class="math display">\[
L_{max}=(1+\epsilon)(\frac{C(v)}{k})
\]</span> 其中<span class="math inline">\(C(v)\)</span>是图中所有节点权重的和，<span class="math inline">\(\epsilon\)</span>是一个范围参数</p>
<p>我们对于每一个节点都设置一个属于他们自己的ID，然后随机遍历每一个节点，将这个节点移动到与之最为相连(边的权重最大)的块中。但是我们要对其尺寸进行约束，每一个block的上界规定为上文的<span class="math inline">\(max(max_vc(v),W)\)</span>。我们定义如果节点<span class="math inline">\(v\)</span>归入到<span class="math inline">\(V_l\)</span>块中，这个块的权重并不会超过上限，那么这个块认为是合格的；反之，则认为其不合格。所以在遍历每一个节点，这个节点要被归入到合格的块中关联最紧密的那个。这样在收缩聚类之后，每一个块都符合约束。上文中的<span class="math inline">\(W=\frac{L_{max}}{f}\)</span>，<span class="math inline">\(f\)</span>是调优参数。</p>
<p>回忆传统的标签传播算法，LPA算法是随机遍历每一个节点，在这里我们规定：<strong>首先遍历度小的节点</strong></p>
<p>聚类+粗化的过程将被递归执行下去，直到图已经变得足够小（每一个粗节点都被划分到了同一个类中）</p>
<h3 id="parallelization">Parallelization</h3>
<p><strong>并行化的标签传播（聚类）：</strong></p>
<p>首先我们将图分成不同的子图放入到每一个PE（处理单元 process element）中，每一个PE获得的子图是节点ID在<span class="math inline">\([a,b]\)</span>中的节点，以及这些节点相关的边，还有一些边的端点（不在区间范围里）（我们称作为ghost节点）。这就意味着，每一个PE可能有将该子图连接到其他PE中的子图中的边。</p>
<p>每一个PE并不使用输入图的节点ID（<span class="math inline">\([a,b]\)</span>），而是将其映射到<span class="math inline">\([0,n_p-1]\)</span>，其中<span class="math inline">\(n_p\)</span>是子图中的节点数量（这里是包括ghost的）。</p>
<p>-&gt; 区间内节点的映射规律为：<span class="math inline">\(i-a\)</span></p>
<p>-&gt; ghost节点的映射到剩下的<span class="math inline">\([b-a, n_p-(b-a+1)]\)</span>，先后顺序根据遍历顺序确定。</p>
<p>我们将区间内节点，下文称为<strong>本地节点</strong>存储到一个数组中，其本地ID和全局ID仅仅相差<span class="math inline">\(a\)</span>；将ghost节点通过哈希表存储全局ID到本地ID的映射，并将其存储到另一个数组中。</p>
<p>我们在每一个PE中都执行PLA，这里注意，由于每一个PE中的节点的ID都被映射到了<span class="math inline">\([0,n_p-1]\)</span>中，所以节点的集群ID也落在这个区间中。</p>
<p><strong>平衡、尺寸约束：</strong></p>
<p>这里文章中使用了两种不同的办法来保持平衡，一个用在粗化中，另一个用在去粗化中。在粗化的过程中，块比较多，所以约束比较软（<span class="math inline">\(\frac{L_{max}}{f}\)</span>）；在去粗化中，块比较少，约束比较严（<span class="math inline">\(L_{max}\)</span>）。</p>
<p>-&gt; 在粗化过程中，PE只维护和更新其本地节点和ghost节点的块的局部节点权重。 由于标签传播算法的初始化方式，每个PE一开始就知道本地节点块和鬼节点块的准确权重。 然后标签传播使用本地信息来绑定块权重。 一旦节点改变其块，本地块权重就会更新。</p>
<p>-&gt; 在去粗化中，每一个PE先本地计算自己块的精确权重，然后将本地块的权重聚合并广播到所有的PE中。现在每个PE都知道所有k个区块的全局区块权重。利用LPA更新本地权重。</p>
<p><strong>并行收缩与去粗化：</strong></p>
<p>-&gt; 并行收缩：每一个PE上聚类的ID可以任意分布在<span class="math inline">\([0,n-1]\)</span>上（n是当前层次下所有的节点数量），因此通过寻找不同聚类id的数量（粗节点的数量）来启动收缩算法。因此，每个PE <span class="math inline">\(p\)</span> 计算ID在区间<span class="math inline">\(I_p=p[\frac{n}{P}]+1...(p+1)[\frac{n}{P}]\)</span>的不同聚类数量（<span class="math inline">\(P\)</span>是使用PE的总数）<strong><em>对应前文的<span class="math inline">\([a,b]\)</span>。</em></strong>这也就意味着每个PE要迭代本地的节点，<u>收集非本地的集群ID <span class="math inline">\(a\)</span>（<span class="math inline">\(a \notin I_p\)</span>），然后将非本地集群的ID发送给对应的PE。</u></p>
<p>设<span class="math inline">\(n&#39;\)</span>是不同聚类ID数，这也是执行收缩后的粗节点数。下一步就是要计算从<span class="math inline">\(C:[0,n-1] \to [0,n&#39;-1]\)</span>的映射。当映射结束后，新的PE <span class="math inline">\(p\)</span> 就会负责<span class="math inline">\(p[\frac{n&#39;}{P}]+1...(p+1)[\frac{n&#39;}{P}]\)</span>的子图。</p>
<p>-&gt; 去粗化：并行去粗化算法实现简单。 每个PE知道子图中所有节点的粗节点（通过映射<span class="math inline">\(C\)</span>）。 因此，PE从保存相应粗节点的PE请求代表精细节点的粗节点的块ID。</p>
<p><strong>整个并行系统的工作方式如下：</strong></p>
<p>我们使用并行尺寸约束标记传播算法的迭代来计算图簇并并行收缩它们。 我们递归地这样做，直到剩余的图剩下不到20,000个节点。 然后在每个PE上收集分布式粗图，即每个PE拥有的完整最粗图的副本。 将该图作为粗粒度分布式进化算法Kaffpae的输入，得到其高质量的K-划分（我们已经修改了Kaffpae，以使用组合操作，这些操作也使用了上面基于聚类的粗化方案）。 然后将进化算法的最优解广播给所有PEs，这些PEs将解转移到分布粗图的局部。 然后，我们使用并行去粗化算法将当前级的解传递到下一个更细的级，并在原划分问题的大小约束下（设置<span class="math inline">\(W=L_{max}\)</span>)应用并行标记传播算法的r次迭代来改进当前级的解。 我们在层次结构的每一个层次上都这样做，并最终获得输入网络的良好分区。</p>
<hr />
<h2 id="深度多层图分割">深度多层图分割</h2>
<blockquote>
<p>网址：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2105.02022">https://arxiv.org/abs/2105.02022</a></p>
<p>Gottesbüren, Lars, et al. "Deep multilevel graph partitioning." <em>arXiv preprint arXiv:2105.02022</em> (2021).</p>
</blockquote>
<h3 id="notation"><strong>Notation</strong></h3>
<p><strong>本文章的平衡约束设置为：</strong><span class="math inline">\(\forall i \in \{1..k\}:c(V_i)\leq L_{max,k}=max\{(1+\epsilon)\frac{c(V)}{k},\frac{c(V)}{k}+max_vc(v)\}\)</span></p>
<ul>
<li>这里有两个约束，并不在是像其他文章只有第一个约束，这里的最大阈值取了两个值的最大值</li>
<li>原因是：找到<span class="math inline">\((1+\epsilon)\frac{c(V)}{k}\)</span>是一个<em>NP完全问题</em>，而<span class="math inline">\(L_{max,k}\)</span>则不是</li>
</ul>
<p><strong>文章的目标：</strong></p>
<ul>
<li><p>将图划分成尽可能均匀的子图</p></li>
<li><p><em><u>切割边的权重是最小的</u></em></p>
<blockquote>
<p>这里可能和BGFL的思路有一些不同，因为我们进行分组是要尽可能组与组之间的差异足够大，组内的差异足够小，所以应该是让分割边的权重最大。🤔</p>
</blockquote></li>
</ul>
<p><strong>多层级图划分：</strong></p>
<p>这是许多高质量图划分器采用的范式：1. 粗化阶段；2. 初始划分；3. 细化</p>
<p>-&gt; 粗化阶段：算法建立一个较小的图，根据聚类方法，将同一类的图压缩成一个节点</p>
<p>-&gt; 初始划分：当粗图的节点数低于某一个阈值或粗化算法收敛，计算最粗图的一个划分</p>
<p>-&gt; 细化：撤销粗化执行的操作，在更精细的图上局部改进</p>
<p>使用多层级范式将图划分为k个block，一般有两种办法：1. 直接k-way划分；2. 递归二划分</p>
<p>-&gt; 直接k-way：将图粗化到只剩下<span class="math inline">\(k·C\)</span>个节点后，计算k-way分区</p>
<p>-&gt; 递归二划分：首先计算一个二划分<span class="math inline">\(\{V_1, V_2\}\)</span>，然后将<span class="math inline">\(V_1\)</span>分成<span class="math inline">\(\frac{k}{2}\)</span>块，同理对待<span class="math inline">\(V_2\)</span>，之后变成问题：<strong>在两个子图中分<span class="math inline">\(\frac{k}{2}\)</span>块，</strong>继续重复操作。</p>
<p>==许多使用直接k-way在初始划分的时候也会选择递归二划分。==</p>
<p><strong>尺寸约束的标签传播算法：</strong></p>
<p><a href="#带有尺寸约束的标签传播算法">带有尺寸约束的标签传播算法</a></p>
<p><strong>保持平衡约束：</strong></p>
<p>为了满足平衡约束：<span class="math inline">\((1+\epsilon)\frac{c(V)}{k}\)</span>，这个问题是一个NP完全问题，因此他可以简化为在相同的并行机器上的调度作业问题，因此，人们采用了一些技术：通过惩罚大权重的节点的收缩 / 强制执行节点权重的严格上限 来防止生成重节点。</p>
<p><u>但是如果我们将<span class="math inline">\(L_{k}\)</span>更换成<span class="math inline">\(L_{max,k}\)</span>，则可以在多项式时间找到平衡分区</u></p>
<p>如果在递归双分区的时候，对每个双分区输入<span class="math inline">\(\epsilon\)</span>，那么在最后的k-way分区的时候就会违反约束。</p>
<p>Therefore，Kahypar提出了一种办法：通过递归二分法获得k-way分区时单独调整每个二分法的不平衡比<span class="math inline">\(\epsilon\)</span>来使得最终的k分区平衡。</p>
<p>设<span class="math inline">\(G[V&#39;]\)</span>是当前二分区的一个子图，他应该递归地规划为<span class="math inline">\(k&#39;&lt;k\)</span>个块。则<span class="math inline">\(\epsilon&#39;\)</span>为二分区的不平衡比。 <span class="math display">\[
\epsilon&#39;=((1+\epsilon)\frac{c(V)}{k}·\frac{k&#39;}{c(V&#39;)})^{\frac{1}{log_2(k&#39;)}-1}
\]</span></p>
<p>如果每一个二分区都是<span class="math inline">\(\epsilon’-balanced\)</span>，那么最后的k-way分区就是<span class="math inline">\(\epsilon-balanced\)</span>。</p>
<h3 id="generic-deep-mgp">Generic Deep MGP</h3>
<p><strong>大体流程：</strong></p>
<p>输入一个图，然后将其进行粗化，一直到只剩下2C个分区（这里C是输入参数），这就是最粗的图了。</p>
<p>然后，我们将这个最粗的图通过二分区，分成两个块。</p>
<p>在去粗化的过程中（将归并的节点还原成多个节点），要保证<span class="math inline">\(n&#39;\)</span>个节点要分成<span class="math inline">\(min\{k,ceil_2(|V_i|/C)\}\)</span>个块，这样每次进行二分区都能在大约2C个点上工作。</p>
<p>直到分出k组。</p>
<p><strong>详细流程：</strong></p>
<p>首先，我们输入图<span class="math inline">\(G_1=(V_1,E_1)\)</span>，然后建立一系列越来越粗的图<span class="math inline">\(G_1, G_2,..,G_l\)</span>。图粗化的办法是对每一个<span class="math inline">\(G_i\)</span>的图进行聚类，然后将类别压缩成一个点来获得<span class="math inline">\(G_{i+1}\)</span>。这个过程直到步骤收敛或者图节点拥有不超过<span class="math inline">\(2C\)</span>个节点。<em>对应算法1:2-3</em></p>
<p><u>此时图中仅有2C个节点，且此时2C个节点并没有分块。</u></p>
<p>之后，我们开始以下操作：</p>
<ol type="1">
<li>使用递归二划分来将当前的图划分成<span class="math inline">\(k_l\)</span>个块；</li>
<li>重新平衡分区并利用k-way局部改进；</li>
<li>将分区映射到前一个图<span class="math inline">\(G_{l-1}\)</span>。</li>
</ol>
<p>在这些操作期间，我们保证以下量不变</p>
<ol type="1">
<li>一个粗图<span class="math inline">\(G_i\)</span>划分成<span class="math inline">\(k_i=ceil_2(|V_i|/C)\)</span>个块</li>
<li><span class="math inline">\(G_i\)</span>的<span class="math inline">\(k_i\)</span>-way分区应该满足平衡约束</li>
</ol>
<blockquote>
<p>解释一下<span class="math inline">\(ceil_2\)</span>，<span class="math inline">\(ceil_2(x)\)</span>的意思是，将x向上取到2的幂次。</p>
<p>eg. <span class="math inline">\(ceil_2(10) \to 16\)</span></p>
<p>所以1条件，就是每一个图分成的块的数量必须是2的幂，这样才能保证二划分。3C个点就要分成4块。</p>
</blockquote>
<p>理想的情况下，算法会产生一个图层次结构，其中节点数在两个层次之间减半，最粗的图有2C个节点。在这种情况下，对最粗的图G进行一次二划分就足以满足1条件。为了在去粗化的时候（将当前图中的节点数增加一倍）后恢复不变量，必须将当前分区的每一个块进行一次二分区。</p>
<blockquote>
<p>eg.</p>
<p>现在最大的图有2C个点，此时需要分区<span class="math inline">\(ceil_2(2C/C)=2\)</span>，所以二分区将其分成两个块</p>
<p>之后映射到前一个图，此时节点变成了4C个，需要分区<span class="math inline">\(cel_2(4C/C)=4\)</span>，在第一步的时候已经分出了两个块，所以再在两个块中分别进行一次二分区就满足了。</p>
</blockquote>
<p>一般的条件下，粗化会将图缩小大于1/2，因此使用递归二划分来保持1条件。也就是说，每当图<span class="math inline">\(G_i\)</span>的划分不满足1条件，就要递归的对每一个块进行二划分，直到拥有<span class="math inline">\(k_i\)</span>个块。<em>对应算法1:7-10</em></p>
<blockquote>
<p>eg.</p>
<p>现在最大的图有2C个点，此时需要分区<span class="math inline">\(ceil_2(2C/C)=2\)</span>，所以二分区将其分成两个块</p>
<p>之后映射到前一个图，此时大概率会变成大于4C个节点，比如说6C个，所以此时分组要分成<span class="math inline">\(cel_2(6C/C)=8\)</span>，此时就需要递归进行二分区，在已经存在的两块中进行二分区，变成4个块，再在4个块中进行二分区，变成8个块。</p>
</blockquote>
<p>因为现实中的节点数量不一定是C的整数倍，所以进行单一二分区是可能没有办法获得<span class="math inline">\(k&#39;\)</span>个分区，所以不满足约束的话会使用k-way局部改进算法，<em>对应算法1:11</em></p>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211081649225.png" style="zoom:80%;" /></p>
<h3 id="parallelization-1">Parallelization</h3>
<p>使用方法：<strong>并行粗化、局部改进、平衡算法</strong></p>
<p>在很粗的层次上，<strong>保持<span class="math inline">\(p\)</span>个PE在至少有<span class="math inline">\(pC\)</span>个节点的图上进行并行任务</strong>，这是通过在越来越多的粗图副本上运行初始化分区来得到的。</p>
<ol type="1">
<li><p>我们使用<a href="#Notation">Notation</a>中的步骤来使得最后的粗图<span class="math inline">\(G_C\)</span>还有<span class="math inline">\(pC\)</span>个节点。(下图中的前三个步骤）</p></li>
<li><p>我们复制<span class="math inline">\(G_C\)</span>得到两个副本<span class="math inline">\(G_C^r\)</span>和<span class="math inline">\(G_C^l\)</span>，同时将PE进行分割成两组，每一组有<span class="math inline">\(p&#39;=\frac{p}{2}\)</span>个PE。如果<span class="math inline">\(p&#39; &gt; 1\)</span>，我们用第一组的PE继续粗化<span class="math inline">\(G_C^r\)</span>，用第二组的PE粗化<span class="math inline">\(G_C^l\)</span>，直到每个图中剩下<span class="math inline">\(p&#39;C\)</span>个节点。（下图三到四的分叉）</p></li>
<li><p>我们以这种方式进行递归，直到最后获得<span class="math inline">\(p\)</span>个有<span class="math inline">\(2C\)</span>节点的图。（下图四到五的二变四，又进行了一次复制，一次粗化）</p></li>
<li><p>然后使用单个PE对这些图中的每一个进行二分区，选择两者中更好的二分区划分，如果就一个可行，那么就用那一个。（下图从五到六）</p>
<blockquote>
<p>比如下图从2C的节点进行复制，因为<span class="math inline">\(p&#39;=2/2=1\)</span>，所以不用再进行粗化，两个PE上各自有一个副本，之后进行二分类，其实就是在两个相同的图上进行二分区。</p>
</blockquote></li>
<li><p>之后我们继续在4中的二分区的每个块进行二分区，并应用平衡和局部改进算法。（下图从六到七）</p></li>
<li><p>递归进行。</p></li>
</ol>
<p><img src="https://raw.githubusercontent.com/ZimingDai/Picture/main/img/202211081543191.png" /></p>
<p><strong>对k的处理：</strong></p>
<p>在上文中，我们默认k是2的倍数。对于一般情况，我们要给B个块分k组，此时<span class="math inline">\(f_V=k\)</span>，我们对B进行二分区<span class="math inline">\(B_0=\lceil\frac{B}{2}\rceil\)</span>，<span class="math inline">\(\lfloor\frac{B}{2}\rfloor\)</span>。同时我们将B的权重分割成了<span class="math inline">\(f_{B_0}\)</span>和<span class="math inline">\(f_{B_1}\)</span>……我们要计算<span class="math inline">\(k&#39;=floor_2(k)\)</span>的<span class="math inline">\(k&#39;-way\)</span>划分。这样就会有<span class="math inline">\(k-k&#39;\)</span>个重块<span class="math inline">\(f=2\)</span>，以及有<span class="math inline">\(2k&#39;-k\)</span>个<span class="math inline">\(f=1\)</span>的轻块，之后我们只要对重块进行双分区就行了。</p>
<blockquote>
<p>eg. k = 7，B = 15</p>
<p>k’=4，所以要进行一个4-分区，用Notation的方法，将15进行4分区，分成了3,4,4,4。</p>
<p>此时有重块3个：4,4,4；轻块1个：3</p>
<p>对重块二分区：2,2,2,2,2,2</p>
<p>最后：2,2,2,2,2,2,3</p>
</blockquote>
<h3 id="merits">Merits</h3>
<p>它成功地结合了经典的直接k-way划分和递归二划分的优点。 与直接K-way划分相似，深度MGP只对图进行一次粗化和去粗化，并允许使用K-way局部改进算法。 当k较大时，它不会遇到可伸缩性问题，并且比递归二划分具有更好的渐近运行时间</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>PhoenixDai
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://phoenixdai.cn/2022/10/26/BGFL-Improve-GraphDiv/" title="BGFL-Improve-GraphDiv">http://phoenixdai.cn/2022/10/26/BGFL-Improve-GraphDiv/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/My-Papers/" rel="tag"># My-Papers</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/22/2022JSAC%20Papers'%20Comprehension/" rel="prev" title="2022JSAC Papers' Comprehension">
      <i class="fa fa-chevron-left"></i> 2022JSAC Papers' Comprehension
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/03/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A-CCF-%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95/" rel="next" title="中国计算机学会(CCF)推荐国际学术会议和期刊目录">
      中国计算机学会(CCF)推荐国际学术会议和期刊目录 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  
  


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#preliminaries"><span class="nav-number">1.</span> <span class="nav-text">Preliminaries</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#super-graph"><span class="nav-number">1.1.</span> <span class="nav-text">Super Graph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">标签传播算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fm-algorithm"><span class="nav-number">1.3.</span> <span class="nav-text">FM Algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#graph-coarsening"><span class="nav-number">1.4.</span> <span class="nav-text">Graph Coarsening</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B9%B3%E8%A1%A1%E5%9B%BE%E5%88%86%E5%89%B2"><span class="nav-number">2.</span> <span class="nav-text">复杂网络的平衡图分割</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89%E5%B0%BA%E5%AF%B8%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%A0%87%E7%AD%BE%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">带有尺寸约束的标签传播算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parallelization"><span class="nav-number">2.2.</span> <span class="nav-text">Parallelization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%A4%9A%E5%B1%82%E5%9B%BE%E5%88%86%E5%89%B2"><span class="nav-number">3.</span> <span class="nav-text">深度多层图分割</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#notation"><span class="nav-number">3.1.</span> <span class="nav-text">Notation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#generic-deep-mgp"><span class="nav-number">3.2.</span> <span class="nav-text">Generic Deep MGP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parallelization-1"><span class="nav-number">3.3.</span> <span class="nav-text">Parallelization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#merits"><span class="nav-number">3.4.</span> <span class="nav-text">Merits</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PhoenixDai"
      src="/images/Phoenix-Logo-White.png">
  <p class="site-author-name" itemprop="name">PhoenixDai</p>
  <div class="site-description" itemprop="description">Anything that doesn't kill me makes me stronger</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ZimingDai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZimingDai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:phoenixdai2001@163.com" title="E-Mail → mailto:phoenixdai2001@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-01 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PhoenixDai</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>


        








      </div>
    </footer>
  </div>

  
  
  <script color='48,0,65' opacity='0.9' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
